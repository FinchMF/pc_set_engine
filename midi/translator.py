"""MIDI translation utility for pitch class sequences.

This module provides functionality to convert sequences generated by the
pitch class rules engine into MIDI files. It supports both melodic sequences
and chord progressions, with customizable parameters for playback.

Features:
- Conversion of melodic sequences to MIDI note sequences
- Conversion of chord progressions to MIDI chord sequences
- Customizable tempo, note duration, and velocity
- Support for octave specification

Examples:
    Convert a melodic sequence to a MIDI file:
    ```python
    from midi.translator import sequence_to_midi
    
    melodic_sequence = [0, 4, 7, 12]  # C, E, G, C
    sequence_to_midi(melodic_sequence, "melody.mid", is_melodic=True)
    ```
    
    Convert a chord progression to a MIDI file:
    ```python
    chord_sequence = [[0, 4, 7], [5, 9, 0], [7, 11, 2]]  # C, F, G
    sequence_to_midi(chord_sequence, "progression.mid", is_melodic=False)
    ```
"""
import mido
from mido import Message, MidiFile, MidiTrack
import os
from typing import List, Union, Dict, Optional, Tuple
import sys
from pathlib import Path
from pc_sets.rhythm import apply_rhythm_to_sequence, RhythmConfig

# Add parent directory to path to allow imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from utils import get_logger
logger = get_logger(__name__)

# Default MIDI parameters
DEFAULT_PARAMS = {
    "tempo": 120,            # BPM
    "base_octave": 4,        # Middle C octave
    "note_duration": 0.5,    # Half-second notes (in seconds)
    "velocity": 64,          # Medium velocity (0-127)
    "channel": 0,            # MIDI channel 1 (0-15)
    "time_signature": (4, 4) # 4/4 time signature
}

# Define default directory for MIDI files
DEFAULT_MIDI_DIR = Path(__file__).parent.parent / "midi_files"

def pc_to_midi_note(pc: int, octave: int = 4) -> int:
    """Convert a pitch class to a MIDI note number.
    
    Args:
        pc: The pitch class (0-11, where 0 is C)
        octave: The octave (default is 4, which puts middle C at 60)
        
    Returns:
        The MIDI note number
        
    Note:
        MIDI note 60 is middle C (C4)
    """
    return pc + (octave + 1) * 12

def sequence_to_midi(
    sequence: List[Union[int, List[int]]],
    output_path: str,
    is_melodic: bool = True,
    params: Dict = None
) -> str:
    """Convert a pitch class sequence to a MIDI file.
    
    Args:
        sequence: The sequence of pitch classes or pitch class sets
        output_path: Path where the MIDI file should be saved
        is_melodic: Whether the sequence is melodic (single notes) or chordal
        params: Dictionary of MIDI parameters (tempo, octave, duration, etc.)
        
    Returns:
        The path to the created MIDI file
        
    Raises:
        ValueError: If the sequence format doesn't match is_melodic parameter
    """
    if not sequence:
        raise ValueError("Empty sequence provided")
        
    # Validate sequence format matches the specified type
    if is_melodic and isinstance(sequence[0], list):
        raise ValueError("Sequence contains lists but is_melodic=True was specified")
    if not is_melodic and not isinstance(sequence[0], list):
        raise ValueError("Sequence contains single notes but is_melodic=False was specified")
        
    # Use default parameters if none provided
    params = params or DEFAULT_PARAMS.copy()
    
    # Handle output path - ensure it's in the midi_files directory
    output_path = _ensure_midi_directory(output_path)
    
    # Create a new MIDI file with one track
    midi_file = MidiFile(type=0)  # Type 0 (single track)
    track = MidiTrack()
    midi_file.tracks.append(track)
    
    # Calculate time delta in MIDI ticks
    ticks_per_beat = midi_file.ticks_per_beat
    tempo_bpm = params.get("tempo", DEFAULT_PARAMS["tempo"])
    
    # Add time signature if specified
    if "time_signature" in params:
        numerator, denominator = params["time_signature"]
        # Format: numerator, denominator, clocks_per_click, notated_32nd_notes_per_beat
        track.append(mido.MetaMessage('time_signature', 
                                      numerator=numerator, 
                                      denominator=denominator, 
                                      clocks_per_click=24, 
                                      notated_32nd_notes_per_beat=8, 
                                      time=0))
    
    # Add tempo setting
    tempo_microseconds = int(60000000 / tempo_bpm)  # Convert BPM to microseconds per beat
    track.append(mido.MetaMessage('set_tempo', tempo=tempo_microseconds, time=0))
    
    # Get parameters
    base_octave = params.get("base_octave", DEFAULT_PARAMS["base_octave"])
    note_duration_sec = params.get("note_duration", DEFAULT_PARAMS["note_duration"])
    velocity = params.get("velocity", DEFAULT_PARAMS["velocity"])
    channel = params.get("channel", DEFAULT_PARAMS["channel"])
    
    # Calculate note duration in ticks
    seconds_per_beat = 60 / tempo_bpm
    beats_per_note = note_duration_sec / seconds_per_beat
    ticks_per_note = int(beats_per_note * ticks_per_beat)
    
    logger.info(f"Converting sequence to MIDI with tempo={tempo_bpm}, duration={note_duration_sec}s")
    
    if is_melodic:
        # Process melodic sequence (single notes)
        _create_melodic_track(track, sequence, base_octave, velocity, channel, ticks_per_note)
    else:
        # Process chord sequence (multiple notes at once)
        _create_chord_track(track, sequence, base_octave, velocity, channel, ticks_per_note)
    
    # End of track marker
    track.append(mido.MetaMessage('end_of_track', time=0))
    
    # Create directory if it doesn't exist
    os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
    
    # Save the file
    midi_file.save(output_path)
    logger.info(f"MIDI file saved to {output_path}")
    
    return output_path

def _ensure_midi_directory(output_path: str) -> str:
    """Ensure the output path is in the midi_files directory.
    
    If the path is not absolute or doesn't specify a directory,
    place it in the default midi_files directory.
    
    Args:
        output_path: The original output path
        
    Returns:
        The modified output path in the midi_files directory
    """
    # Create the midi_files directory if it doesn't exist
    DEFAULT_MIDI_DIR.mkdir(exist_ok=True)
    
    # Check if the path is absolute
    if not os.path.isabs(output_path):
        # Check if the path includes a directory
        if os.path.dirname(output_path):
            # The path includes a relative directory, preserve it under midi_files
            rel_dir = os.path.dirname(output_path)
            filename = os.path.basename(output_path)
            full_dir = DEFAULT_MIDI_DIR / rel_dir
            full_dir.mkdir(exist_ok=True, parents=True)
            return str(full_dir / filename)
        else:
            # No directory specified, put directly in midi_files
            return str(DEFAULT_MIDI_DIR / output_path)
    
    # It's an absolute path, preserve it
    return output_path

def _create_melodic_track(
    track: MidiTrack, 
    sequence: List[int],
    base_octave: int,
    velocity: int,
    channel: int,
    ticks_per_note: int
) -> None:
    """Create a MIDI track for a melodic sequence.
    
    Args:
        track: The MIDI track to add notes to
        sequence: The melodic sequence (list of pitch classes)
        base_octave: The base octave for the notes
        velocity: The note velocity (loudness)
        channel: The MIDI channel
        ticks_per_note: Duration of each note in MIDI ticks
    """
    for pc in sequence:
        # Convert pitch class to MIDI note
        note = pc_to_midi_note(pc, base_octave)
        
        # Add note_on message
        track.append(Message('note_on', note=note, velocity=velocity, 
                           time=0, channel=channel))
        
        # Add note_off message after the duration
        track.append(Message('note_off', note=note, velocity=0, 
                           time=ticks_per_note, channel=channel))

def _create_chord_track(
    track: MidiTrack, 
    sequence: List[List[int]],
    base_octave: int,
    velocity: int,
    channel: int,
    ticks_per_note: int
) -> None:
    """Create a MIDI track for a chord sequence.
    
    Args:
        track: The MIDI track to add notes to
        sequence: The chord sequence (list of pitch class sets)
        base_octave: The base octave for the notes
        velocity: The note velocity (loudness)
        channel: The MIDI channel
        ticks_per_note: Duration of each chord in MIDI ticks
    """
    for chord in sequence:
        # For each chord, add all notes simultaneously
        for i, pc in enumerate(chord):
            note = pc_to_midi_note(pc, base_octave)
            
            # First note has time=0, others also have time=0 to play simultaneously
            track.append(Message('note_on', note=note, velocity=velocity, 
                               time=0, channel=channel))
        
        # Add note_off messages for all notes after the duration
        # First note_off has the full duration, others have time=0
        for i, pc in enumerate(chord):
            note = pc_to_midi_note(pc, base_octave)
            time = ticks_per_note if i == 0 else 0
            track.append(Message('note_off', note=note, velocity=0, 
                               time=time, channel=channel))

def load_and_convert_sequence(
    json_path: str,
    output_path: str = None,
    params: Dict = None
) -> str:
    """Load a sequence from a JSON file and convert it to MIDI.
    
    Args:
        json_path: Path to the JSON file containing the sequence
        output_path: Path where the MIDI file should be saved (default: same name as JSON)
        params: Dictionary of MIDI parameters
        
    Returns:
        The path to the created MIDI file
    """
    import json
    
    with open(json_path, 'r') as f:
        data = json.load(f)
    
    sequence = data.get('sequence')
    if not sequence:
        raise ValueError("No sequence found in JSON file")
    
    # Determine if the sequence is melodic or chordal
    is_melodic = not isinstance(sequence[0], list)
    
    # If no output path specified, use the same name as the input with .mid extension
    if output_path is None:
        basename = os.path.basename(json_path)
        basename_no_ext = os.path.splitext(basename)[0]
        output_path = f"{basename_no_ext}.mid"
    
    return sequence_to_midi(sequence, output_path, is_melodic, params)

def enhance_with_rhythm(
    sequence: List[Union[int, List[int]]],
    rhythm_pattern: List[float],
    is_melodic: bool = True
) -> Tuple[List[Union[int, List[int]]], List[float]]:
    """Enhance a sequence with a rhythmic pattern.
    
    Args:
        sequence: The original pitch class sequence
        rhythm_pattern: A list of note durations (in beats)
        is_melodic: Whether the sequence is melodic or chordal
        
    Returns:
        A tuple containing the original sequence and a list of durations
        
    Example:
        ```python
        sequence = [0, 4, 7, 0]  # C, E, G, C
        rhythm = [1, 0.5, 0.5, 2]  # Quarter, eighth, eighth, half notes
        sequence, durations = enhance_with_rhythm(sequence, rhythm)
        ```
    """
    # Repeat the rhythm pattern if it's shorter than the sequence
    if len(rhythm_pattern) < len(sequence):
        repeats = (len(sequence) // len(rhythm_pattern)) + 1
        rhythm_pattern = (rhythm_pattern * repeats)[:len(sequence)]
    
    return sequence, rhythm_pattern

def sequence_to_midi_with_rhythm(
    sequence: List[Union[int, List[int]]],
    filename: str,
    is_melodic: bool = True,
    rhythm_config: Optional[Union[Dict, RhythmConfig]] = None,
    params: Dict = None
) -> str:
    """Convert a pitch class sequence to MIDI with rhythm applied.
    
    Creates a MIDI file from a pitch class sequence, applying rhythm
    patterns based on the provided rhythm configuration.
    
    Args:
        sequence: The pitch class sequence to convert.
        filename: Path where the MIDI file should be saved.
        is_melodic: Whether the sequence contains single notes (True) or chords (False).
        rhythm_config: Configuration for rhythm generation.
        params: Additional parameters for MIDI generation.
        
    Returns:
        Path to the generated MIDI file.
        
    Example:
        ```python
        rhythm_config = {"time_signature": (4, 4), "subdivision": 8, "accent_type": "downbeat"}
        sequence_to_midi_with_rhythm(sequence, "output.mid", is_melodic=True, rhythm_config=rhythm_config)
        ```
    """
    logger.info(f"Converting sequence to MIDI with rhythm: {filename}")
    
    # Set default parameters
    if params is None:
        params = {}
    
    tempo = params.get('tempo', 120)
    base_octave = params.get('base_octave', 4)
    
    # Apply rhythm to sequence
    if rhythm_config:
        timed_sequence = apply_rhythm_to_sequence(sequence, rhythm_config, is_melodic)
    else:
        # Default rhythm if no config provided (quarter notes)
        default_rhythm = {"time_signature": (4, 4), "subdivision": 1, "accent_type": "downbeat"}
        timed_sequence = apply_rhythm_to_sequence(sequence, default_rhythm, is_melodic)
    
    # Create a MIDI file
    mid = mido.MidiFile()
    track = mido.MidiTrack()
    mid.tracks.append(track)
    
    # Set tempo
    track.append(mido.MetaMessage('set_tempo', tempo=mido.bpm2tempo(tempo)))
    
    # Set time signature if provided in rhythm_config
    if rhythm_config and hasattr(rhythm_config, 'time_signature'):
        numerator, denominator = rhythm_config.time_signature
        track.append(mido.MetaMessage('time_signature', 
                                     numerator=numerator, 
                                     denominator=denominator,
                                     clocks_per_click=24,
                                     notated_32nd_notes_per_beat=8))
    
    # Calculate ticks per beat
    ticks_per_beat = mid.ticks_per_beat
    
    # Track current time
    current_time = 0
    
    # Add notes with rhythm
    for note_data in timed_sequence:
        # Get duration in beats
        duration = note_data['duration']
        duration_ticks = int(duration * ticks_per_beat)
        
        # Get velocity from note_data or use default
        velocity = note_data.get('velocity', 64)
        
        # Convert to MIDI note format
        if is_melodic:
            # Single note
            pitch = note_data['pitch']
            midi_note = pitch + (base_octave * 12)
            
            # Note on
            track.append(mido.Message('note_on', note=midi_note, velocity=velocity, time=0))
            # Note off
            track.append(mido.Message('note_off', note=midi_note, velocity=0, time=duration_ticks))
        else:
            # Chord
            pitches = note_data['pitches']
            midi_notes = [p + (base_octave * 12) for p in pitches]
            
            # Note on for all pitches
            for i, midi_note in enumerate(midi_notes):
                track.append(mido.Message('note_on', note=midi_note, velocity=velocity, time=0 if i > 0 else 0))
                
            # Note off for all pitches after duration
            for i, midi_note in enumerate(midi_notes):
                track.append(mido.Message('note_off', note=midi_note, velocity=0, 
                                        time=duration_ticks if i == 0 else 0))
        
        current_time += duration_ticks
    
    # End of track marker
    track.append(mido.MetaMessage('end_of_track', time=0))
    
    # Save to file
    mid.save(filename)
    logger.info(f"MIDI file saved: {filename}")
    
    return filename


if __name__ == "__main__":
    # Simple demonstration
    test_melody = [0, 2, 4, 5, 7, 9, 11, 12]  # C major scale
    sequence_to_midi(test_melody, "test_melody.mid", is_melodic=True)
    
    test_chords = [[0, 4, 7], [2, 5, 9], [4, 7, 11], [5, 9, 0]]  # C, Dm, Em, F
    sequence_to_midi(test_chords, "test_chords.mid", is_melodic=False)
    
    # With custom rhythm
    rhythm = [1, 0.5, 0.5, 1, 0.5, 0.5, 1, 1]  # quarter, eighth, eighth, etc.
    sequence_to_midi_with_rhythm(test_melody, "test_rhythm.mid", rhythm, is_melodic=True)
    
    print(f"MIDI files saved to {DEFAULT_MIDI_DIR}")
